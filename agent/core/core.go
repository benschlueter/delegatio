/* SPDX-License-Identifier: AGPL-3.0-only
 * Copyright (c) Benedict Schlueter
 * Copyright (c) Edgeless Systems GmbH
 */

package core

import (
	"context"
	"errors"
	"fmt"
	"net"
	"os"
	"os/exec"
	"path/filepath"
	"sync"
	"time"

	"github.com/benschlueter/delegatio/agent/vmapi/vmproto"
	"github.com/benschlueter/delegatio/internal/config"
	"go.uber.org/zap"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	clientset "k8s.io/client-go/kubernetes"
	"k8s.io/client-go/tools/clientcmd"
	certutil "k8s.io/client-go/util/cert"
	bootstraputil "k8s.io/cluster-bootstrap/token/util"
	bootstraptoken "k8s.io/kubernetes/cmd/kubeadm/app/apis/bootstraptoken/v1"
	kubeadm "k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/v1beta3"
	kubeconstants "k8s.io/kubernetes/cmd/kubeadm/app/constants"
	tokenphase "k8s.io/kubernetes/cmd/kubeadm/app/phases/bootstraptoken/node"
	"k8s.io/kubernetes/cmd/kubeadm/app/util/kubeconfig"
	"k8s.io/kubernetes/cmd/kubeadm/app/util/pubkeypin"
)

// Core is responsible for maintaining state information
// of the VM-agent. Currently we do not need any state.
type Core struct {
	zaplogger            *zap.Logger
	mux                  sync.Mutex
	client               clientset.Interface
	masterLoadbalancerIP string
}

// NewCore creates and initializes a new Core object.
func NewCore(zapLogger *zap.Logger, loadbalancerIP string) (*Core, error) {
	c := &Core{
		zaplogger:            zapLogger,
		masterLoadbalancerIP: loadbalancerIP,
		mux:                  sync.Mutex{},
		client:               nil,
	}
	return c, nil
}

// ConnectToKubernetes connects to the Kubernetes API server.
func (c *Core) ConnectToKubernetes() error {
	c.zaplogger.Info("Connecting to Kubernetes")
	config, err := clientcmd.BuildConfigFromFlags("", "/etc/kubernetes/admin.conf")
	if err != nil {
		return fmt.Errorf("creating Kubernetes client config: %w", err)
	}
	client, err := clientset.NewForConfig(config)
	if err != nil {
		return fmt.Errorf("creating Kubernetes client: %w", err)
	}
	c.zaplogger.Info("Connected to Kubernetes")
	c.client = client
	return nil
}

// GetJoinToken creates a new bootstrap (join) token, which a node can use to join the cluster.
func (c *Core) GetJoinToken(ttl time.Duration) (*kubeadm.BootstrapTokenDiscovery, error) {
	// c.log.Infof("Generating new random bootstrap token")
	rawToken, err := bootstraputil.GenerateBootstrapToken()
	if err != nil {
		return nil, fmt.Errorf("couldn't generate random token: %w", err)
	}
	tokenStr, err := bootstraptoken.NewBootstrapTokenString(rawToken)
	if err != nil {
		return nil, fmt.Errorf("invalid token: %w", err)
	}
	token := bootstraptoken.BootstrapToken{
		Token:       tokenStr,
		Description: "Bootstrap token generated by Constellation's Join service",
		TTL:         &metav1.Duration{Duration: ttl},
		Usages:      kubeconstants.DefaultTokenUsages,
		Groups:      kubeconstants.DefaultTokenGroups,
	}

	// create the token in Kubernetes
	// k.log.Infof("Creating bootstrap token in Kubernetes")
	if err := tokenphase.CreateNewTokens(c.client, []bootstraptoken.BootstrapToken{token}); err != nil {
		return nil, fmt.Errorf("creating bootstrap token: %w", err)
	}

	// parse Kubernetes CA certs
	// k.log.Infof("Preparing join token for new node")
	rawConfig, err := os.ReadFile("/etc/kubernetes/admin.conf")
	if err != nil {
		return nil, fmt.Errorf("loading kubeconfig file: %w", err)
	}
	config, err := clientcmd.Load(rawConfig)
	if err != nil {
		return nil, fmt.Errorf("loading kubeconfig file: %w", err)
	}
	_, clusterConfig := kubeconfig.GetClusterFromKubeConfig(config)
	if clusterConfig == nil {
		return nil, errors.New("couldn't get cluster config from kubeconfig file")
	}
	caCerts, err := certutil.ParseCertsPEM(clusterConfig.CertificateAuthorityData)
	if err != nil {
		return nil, fmt.Errorf("parsing CA certs: %w", err)
	}
	publicKeyPins := make([]string, 0, len(caCerts))
	for _, caCert := range caCerts {
		publicKeyPins = append(publicKeyPins, pubkeypin.Hash(caCert))
	}

	// k.log.Infof("Join token creation successful")
	return &kubeadm.BootstrapTokenDiscovery{
		Token:             tokenStr.String(),
		APIServerEndpoint: net.JoinHostPort(c.masterLoadbalancerIP, "6443"),
		CACertHashes:      publicKeyPins,
	}, nil
}

// JoinCluster joins the Kube Cluster.
// TODO: Authentication checks.
func (c *Core) JoinCluster(ctx context.Context) error {
	c.mux.Lock()
	defer c.mux.Unlock()
	c.zaplogger.Info("dial master")
	conn, err := grpc.DialContext(ctx, net.JoinHostPort(c.masterLoadbalancerIP, config.PublicAPIport), grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithBlock())
	if err != nil {
		return err
	}
	defer conn.Close()
	client := vmproto.NewAPIClient(conn)
	c.zaplogger.Info("grpc call to master")
	joinData, err := client.GetJoinDataKube(ctx, &vmproto.GetJoinDataKubeRequest{})
	if err != nil {
		return err
	}

	c.zaplogger.Info("writing files")
	for _, file := range joinData.Files {
		err := os.WriteFile(filepath.Join(kubeconstants.KubernetesDir, kubeconstants.DefaultCertificateDir, file.GetName()), file.GetContent(), 0o644)
		if err != nil {
			return err
		}
	}
	c.zaplogger.Info("executing kubeadm")
	if err := c.executeKubeadm(ctx, joinData.JoinToken.ApiServerEndpoint, joinData.JoinToken.Token, joinData.JoinToken.CaCertHash); err != nil {
		return err
	}
	c.zaplogger.Info("connecting to kubernetes")
	if err := c.ConnectToKubernetes(); err != nil {
		return err
	}

	return nil
}

func (c *Core) executeKubeadm(ctx context.Context, endpoint, token, caCert string) error {
	command := exec.CommandContext(ctx, "/usr/bin/kubeadm", "join", endpoint,
		"--token", token,
		"--discovery-token-ca-cert-hash", caCert,
		//"--node-name", id,
	)
	if err := command.Start(); err != nil {
		return err
	}
	if err := command.Wait(); err != nil {
		return err
	}
	return nil
}

// TryJoinCluster tries to join the cluster every 5 seconds until it succeeds.
func (c *Core) TryJoinCluster(ctx context.Context) {
	ticker := time.NewTicker(5 * time.Second)
	defer ticker.Stop()
	for {
		select {
		case <-ticker.C:
			if c.client != nil {
				return
			}
			c.zaplogger.Info("before joining cluster")
			if err := c.JoinCluster(ctx); err != nil {
				c.zaplogger.Info("Failed to join cluster, retrying in 5 seconds")
			}
		case <-ctx.Done():
			return
		}
	}
}

// IsInReadyState returns true if the Core is in a ready state.
func (c *Core) IsInReadyState() bool {
	return c.client != nil
}

// GetControlPlaneCertificatesAndKeys loads the Kubernetes CA certificates and keys.
func (c *Core) GetControlPlaneCertificatesAndKeys() (map[string][]byte, error) {
	c.zaplogger.Info("Loading control plane certificates and keys")
	controlPlaneFiles := make(map[string][]byte)

	filenames := []string{
		kubeconstants.CAKeyName,
		kubeconstants.ServiceAccountPrivateKeyName,
		kubeconstants.FrontProxyCAKeyName,
		kubeconstants.EtcdCAKeyName,
		kubeconstants.CACertName,
		kubeconstants.ServiceAccountPublicKeyName,
		kubeconstants.FrontProxyCACertName,
		kubeconstants.EtcdCACertName,
	}

	for _, filename := range filenames {
		key, err := os.ReadFile(filepath.Join(kubeconstants.KubernetesDir, kubeconstants.DefaultCertificateDir, filename))
		if err != nil {
			return nil, err
		}
		controlPlaneFiles[filename] = key
	}

	return controlPlaneFiles, nil
}

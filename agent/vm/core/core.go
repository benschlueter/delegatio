/* SPDX-License-Identifier: AGPL-3.0-only
 * Copyright (c) Benedict Schlueter
 * Copyright (c) Edgeless Systems GmbH
 */

package core

import (
	"context"
	"errors"
	"fmt"
	"net"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"sync"
	"time"

	"github.com/benschlueter/delegatio/agent/vm/core/state"
	"github.com/benschlueter/delegatio/agent/vm/vmapi"
	"go.uber.org/zap"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	clientset "k8s.io/client-go/kubernetes"
	"k8s.io/client-go/tools/clientcmd"
	certutil "k8s.io/client-go/util/cert"
	bootstraputil "k8s.io/cluster-bootstrap/token/util"
	tokenv1 "k8s.io/kubernetes/cmd/kubeadm/app/apis/bootstraptoken/v1"
	kubeadm "k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/v1beta4"
	kubeconstants "k8s.io/kubernetes/cmd/kubeadm/app/constants"
	tokenphase "k8s.io/kubernetes/cmd/kubeadm/app/phases/bootstraptoken/node"
	"k8s.io/kubernetes/cmd/kubeadm/app/util/kubeconfig"
	"k8s.io/kubernetes/cmd/kubeadm/app/util/pubkeypin"
)

// Core is responsible for maintaining state information
// of the VM-agent. Currently we do not need any state.
type Core struct {
	State                state.State
	zaplogger            *zap.Logger
	mux                  sync.Mutex
	client               clientset.Interface
	masterLoadbalancerIP string
	api                  vmapi.VMAPI
}

// NewCore creates and initializes a new Core object.
func NewCore(zapLogger *zap.Logger, loadbalancerIP string, api vmapi.VMAPI) (*Core, error) {
	c := &Core{
		zaplogger:            zapLogger,
		masterLoadbalancerIP: loadbalancerIP,
		mux:                  sync.Mutex{},
		client:               nil,
		api:                  api,
	}
	return c, nil
}

// ConnectToKubernetes connects to the Kubernetes API server.
func (c *Core) ConnectToKubernetes() error {
	c.zaplogger.Info("Connecting to Kubernetes")
	config, err := clientcmd.BuildConfigFromFlags("", "/etc/kubernetes/admin.conf")
	if err != nil {
		return fmt.Errorf("creating Kubernetes client config: %w", err)
	}
	client, err := clientset.NewForConfig(config)
	if err != nil {
		return fmt.Errorf("creating Kubernetes client: %w", err)
	}
	c.zaplogger.Info("Connected to Kubernetes")
	c.client = client
	return nil
}

// GetJoinToken creates a new bootstrap (join) token, which a node can use to join the cluster.
func (c *Core) GetJoinToken(ttl time.Duration) (*kubeadm.BootstrapTokenDiscovery, error) {
	// c.log.Infof("Generating new random bootstrap token")
	rawToken, err := bootstraputil.GenerateBootstrapToken()
	if err != nil {
		return nil, fmt.Errorf("couldn't generate random token: %w", err)
	}
	tokenStr, err := tokenv1.NewBootstrapTokenString(rawToken)
	if err != nil {
		return nil, fmt.Errorf("invalid token: %w", err)
	}
	token := tokenv1.BootstrapToken{
		Token:       tokenStr,
		Description: "Bootstrap token generated by Constellation's Join service",
		TTL:         &metav1.Duration{Duration: ttl},
		Usages:      tokenv1.DefaultTokenUsages,
		Groups:      tokenv1.DefaultTokenGroups,
	}

	// create the token in Kubernetes
	// k.log.Infof("Creating bootstrap token in Kubernetes")
	if err := tokenphase.CreateNewTokens(c.client, []tokenv1.BootstrapToken{token}); err != nil {
		return nil, fmt.Errorf("creating bootstrap token: %w", err)
	}

	// parse Kubernetes CA certs
	// k.log.Infof("Preparing join token for new node")
	rawConfig, err := os.ReadFile("/etc/kubernetes/admin.conf")
	if err != nil {
		return nil, fmt.Errorf("loading kubeconfig file: %w", err)
	}
	config, err := clientcmd.Load(rawConfig)
	if err != nil {
		return nil, fmt.Errorf("loading kubeconfig file: %w", err)
	}
	_, clusterConfig := kubeconfig.GetClusterFromKubeConfig(config)
	if clusterConfig == nil {
		return nil, errors.New("couldn't get cluster config from kubeconfig file")
	}
	caCerts, err := certutil.ParseCertsPEM(clusterConfig.CertificateAuthorityData)
	if err != nil {
		return nil, fmt.Errorf("parsing CA certs: %w", err)
	}
	publicKeyPins := make([]string, 0, len(caCerts))
	for _, caCert := range caCerts {
		publicKeyPins = append(publicKeyPins, pubkeypin.Hash(caCert))
	}

	// k.log.Infof("Join token creation successful")
	return &kubeadm.BootstrapTokenDiscovery{
		Token:             tokenStr.String(),
		APIServerEndpoint: net.JoinHostPort(c.masterLoadbalancerIP, "6443"),
		CACertHashes:      publicKeyPins,
	}, nil
}

// JoinCluster joins the Kube Cluster.
// TODO: Authentication checks.
func (c *Core) JoinCluster(ctx context.Context) error {
	c.mux.Lock()
	defer c.mux.Unlock()
	// Advance the state to JoiningCluster
	if err := c.State.Require(state.AcceptingInit); err != nil {
		return err
	}
	joinData, err := c.api.GetJoinData(ctx)
	if err != nil {
		return err
	}
	hostname, err := os.Hostname()
	if err != nil {
		return err
	}
	controlPlane := false
	if strings.Contains(hostname, "delegatio-master") {

		c.zaplogger.Info("creating directories")
		if err := os.MkdirAll(filepath.Join(kubeconstants.KubernetesDir, kubeconstants.DefaultCertificateDir, "etcd"), os.ModePerm); err != nil {
			return err
		}
		c.zaplogger.Info("writing files")
		for _, file := range joinData.Files {
			err := os.WriteFile(filepath.Join(kubeconstants.KubernetesDir, kubeconstants.DefaultCertificateDir, file.GetName()), file.GetContent(), 0o644)
			if err != nil {
				return err
			}
		}
		controlPlane = true
	}
	c.zaplogger.Info("executing kubeadm", zap.String("endpoint", joinData.JoinToken.ApiServerEndpoint), zap.String("token", joinData.JoinToken.Token), zap.String("caCertHash", joinData.JoinToken.CaCertHash), zap.Bool("controlPlane", controlPlane))
	if err := c.executeKubeadm(ctx, joinData.JoinToken.ApiServerEndpoint, joinData.JoinToken.Token, joinData.JoinToken.CaCertHash, controlPlane); err != nil {
		c.zaplogger.Error("failed to execute kubeadm", zap.Error(err))
		return err
	}
	c.State.Advance(state.Initialized)
	return nil
}

func (c *Core) executeKubeadm(ctx context.Context, endpoint, token, caCert string, controlPlane bool) error {
	args := []string{
		"join", endpoint,
		"--token", token,
		"--discovery-token-ca-cert-hash", caCert,
		//"--node-name", id,
	}
	if controlPlane {
		args = append(args, "--control-plane")
	}

	command := exec.CommandContext(ctx, "/usr/bin/kubeadm", args...)

	fmt.Printf("/usr/bin/kubeadm join %s --token %s --discovery-token-ca-cert-hash %s\n", endpoint, token, caCert)
	output, err := command.CombinedOutput()
	if err != nil {
		return fmt.Errorf("command exited with error code: %w and output: %s", err, output)
	}

	return nil
}

// TryJoinCluster tries to join the cluster every 5 seconds until it succeeds.
func (c *Core) TryJoinCluster(ctx context.Context) {
	ticker := time.NewTicker(5 * time.Second)
	defer ticker.Stop()
	for {
		select {
		case <-ticker.C:
			if c.State.Get() >= state.JoiningCluster {
				return
			}
			if err := c.JoinCluster(ctx); err != nil {
				c.zaplogger.Info("Failed to join cluster, retrying in 5 seconds", zap.Error(err))
			}
		case <-ctx.Done():
			return
		}
	}
}

// IsInReadyState returns true if the Core is in a ready state.
func (c *Core) IsInReadyState() bool {
	return c.client != nil
}

// IsReadyForInit returns true if the Core is in a ready state.
func (c *Core) IsReadyForInit() bool {
	return c.State.Get() == state.AcceptingInit
}

// SetJoiningCluster returns true if the Core is in a ready state.
func (c *Core) SetJoiningCluster() {
	// reason later about race conditions / if lock is needed
	c.mux.Lock()
	c.State.Advance(state.JoiningCluster)
	c.mux.Unlock()
}

func (c *Core) SetInitialized() {
	// reason later about race conditions / if lock is needed
	c.mux.Lock()
	c.State.Advance(state.Initialized)
	c.mux.Unlock()
}

// GetControlPlaneCertificatesAndKeys loads the Kubernetes CA certificates and keys.
func (c *Core) GetControlPlaneCertificatesAndKeys() (map[string][]byte, error) {
	c.zaplogger.Info("Loading control plane certificates and keys")
	controlPlaneFiles := make(map[string][]byte)

	filenames := []string{
		kubeconstants.CAKeyName,
		kubeconstants.ServiceAccountPrivateKeyName,
		kubeconstants.FrontProxyCAKeyName,
		kubeconstants.EtcdCAKeyName,
		kubeconstants.CACertName,
		kubeconstants.ServiceAccountPublicKeyName,
		kubeconstants.FrontProxyCACertName,
		kubeconstants.EtcdCACertName,
	}

	for _, filename := range filenames {
		key, err := os.ReadFile(filepath.Join(kubeconstants.KubernetesDir, kubeconstants.DefaultCertificateDir, filename))
		if err != nil {
			return nil, err
		}
		controlPlaneFiles[filename] = key
	}

	return controlPlaneFiles, nil
}
